# Contact Form Submission Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Wire up the contact form to submit data to Google Sheets and send email notifications via Resend, with honeypot spam protection and IP-based rate limiting via Cloudflare KV.

**Architecture:** Next.js Server Action receives form data, validates server-side, checks honeypot + rate limit, then calls Resend API and Google Sheets API in parallel. All secrets and bindings accessed via `getCloudflareContext()` from `@opennextjs/cloudflare`.

**Tech Stack:** Next.js 16 Server Actions, Cloudflare Workers KV, Resend REST API, Google Sheets REST API v4 with service account JWT (Web Crypto API for signing).

---

### Task 1: Install Dependencies & Configure Cloudflare Bindings

**Files:**
- Modify: `package.json` (add `resend`)
- Modify: `wrangler.jsonc` (add KV binding + vars)
- Create: `.dev.vars.example` (document required secrets)

**Step 1: Install resend package**

Run: `npm install resend`

**Step 2: Add KV binding and vars to wrangler.jsonc**

Add after the `"upload_source_maps": true` line:

```jsonc
	"kv_namespaces": [
		{
			"binding": "CONTACT_RATE_LIMIT",
			"id": "<KV_NAMESPACE_ID>"
		}
	],
	"vars": {
		"RESEND_FROM_EMAIL": "noreply@earthboundminerals.com",
		"CONTACT_TO_EMAIL": "info@earthboundminerals.com"
	}
```

Note: The actual KV namespace ID will be filled in after running `wrangler kv namespace create CONTACT_RATE_LIMIT`. Secrets (`RESEND_API_KEY`, `GOOGLE_SERVICE_ACCOUNT_KEY`, `GOOGLE_SHEET_ID`) are set via `wrangler secret put` and NOT added to wrangler.jsonc.

**Step 3: Create .dev.vars.example**

```
# Copy to .dev.vars and fill in values for local development
RESEND_API_KEY=re_xxxxxxxxxxxx
GOOGLE_SERVICE_ACCOUNT_KEY={"type":"service_account","project_id":"...","private_key":"...","client_email":"..."}
GOOGLE_SHEET_ID=your-spreadsheet-id-here
RESEND_FROM_EMAIL=noreply@earthboundminerals.com
CONTACT_TO_EMAIL=info@earthboundminerals.com
```

**Step 4: Update Cloudflare.Env type**

The `env.d.ts` is auto-generated by `wrangler types`. We need to update the `Cloudflare.Env` interface at the top (lines 4-8) to include our new bindings. After adding the KV namespace to `wrangler.jsonc`, run:

Run: `npm run cf-typegen`

This regenerates `env.d.ts` with the new bindings. However, secrets set via `wrangler secret put` won't appear automatically. We need to manually add them to the `Cloudflare.Env` interface:

```typescript
declare namespace Cloudflare {
	interface Env {
		ASSETS: Fetcher;
		CONTACT_RATE_LIMIT: KVNamespace;
		RESEND_API_KEY: string;
		GOOGLE_SERVICE_ACCOUNT_KEY: string;
		GOOGLE_SHEET_ID: string;
		RESEND_FROM_EMAIL: string;
		CONTACT_TO_EMAIL: string;
	}
}
```

Since `env.d.ts` gets overwritten by `cf-typegen`, create a separate declaration file instead:

Create `src/types/cloudflare.d.ts`:

```typescript
declare namespace Cloudflare {
  interface Env {
    CONTACT_RATE_LIMIT: KVNamespace;
    RESEND_API_KEY: string;
    GOOGLE_SERVICE_ACCOUNT_KEY: string;
    GOOGLE_SHEET_ID: string;
    RESEND_FROM_EMAIL: string;
    CONTACT_TO_EMAIL: string;
  }
}
```

TypeScript will merge the namespace declarations from both `env.d.ts` and this file.

**Step 5: Commit**

```bash
git add package.json package-lock.json wrangler.jsonc .dev.vars.example src/types/cloudflare.d.ts
git commit -m "feat: add Cloudflare KV binding, resend dep, and env types for contact submission"
```

---

### Task 2: Create Rate Limiting Module

**Files:**
- Create: `src/lib/rate-limit.ts`
- Create: `src/lib/__tests__/rate-limit.test.ts`

**Step 1: Write the failing test**

Create `src/lib/__tests__/rate-limit.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import { checkRateLimit } from "../rate-limit";

function createMockKV(storedValue: string | null = null) {
  return {
    get: vi.fn().mockResolvedValue(storedValue),
    put: vi.fn().mockResolvedValue(undefined),
  } as unknown as KVNamespace;
}

describe("checkRateLimit", () => {
  it("allows first request from an IP", async () => {
    const kv = createMockKV(null);
    const result = await checkRateLimit(kv, "192.168.1.1", 5);
    expect(result.allowed).toBe(true);
    expect(kv.put).toHaveBeenCalledWith("rate:192.168.1.1", "1", {
      expirationTtl: 3600,
    });
  });

  it("allows requests under the limit", async () => {
    const kv = createMockKV("3");
    const result = await checkRateLimit(kv, "192.168.1.1", 5);
    expect(result.allowed).toBe(true);
    expect(kv.put).toHaveBeenCalledWith("rate:192.168.1.1", "4", {
      expirationTtl: 3600,
    });
  });

  it("blocks requests at the limit", async () => {
    const kv = createMockKV("5");
    const result = await checkRateLimit(kv, "192.168.1.1", 5);
    expect(result.allowed).toBe(false);
    expect(kv.put).not.toHaveBeenCalled();
  });

  it("blocks requests over the limit", async () => {
    const kv = createMockKV("10");
    const result = await checkRateLimit(kv, "192.168.1.1", 5);
    expect(result.allowed).toBe(false);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npx vitest run src/lib/__tests__/rate-limit.test.ts`
Expected: FAIL — module not found

**Step 3: Write minimal implementation**

Create `src/lib/rate-limit.ts`:

```typescript
const RATE_LIMIT_TTL = 3600; // 1 hour in seconds

export async function checkRateLimit(
  kv: KVNamespace,
  ip: string,
  limit: number,
): Promise<{ allowed: boolean }> {
  const key = `rate:${ip}`;
  const current = await kv.get(key);
  const count = current ? parseInt(current, 10) : 0;

  if (count >= limit) {
    return { allowed: false };
  }

  await kv.put(key, String(count + 1), { expirationTtl: RATE_LIMIT_TTL });
  return { allowed: true };
}
```

**Step 4: Run test to verify it passes**

Run: `npx vitest run src/lib/__tests__/rate-limit.test.ts`
Expected: All 4 tests PASS

**Step 5: Commit**

```bash
git add src/lib/rate-limit.ts src/lib/__tests__/rate-limit.test.ts
git commit -m "feat: add KV-based rate limiting module with tests"
```

---

### Task 3: Create Google Sheets Module

**Files:**
- Create: `src/lib/google-sheets.ts`
- Create: `src/lib/__tests__/google-sheets.test.ts`

This module uses the Google Sheets REST API v4 with a service account. JWT signing uses Web Crypto API (available in Cloudflare Workers).

**Step 1: Write the failing test**

Create `src/lib/__tests__/google-sheets.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import { createJWT, appendToSheet } from "../google-sheets";

describe("createJWT", () => {
  it("creates a JWT with correct claims", async () => {
    const jwt = await createJWT(
      "test@example.iam.gserviceaccount.com",
      // RSA private key in PKCS8 PEM format (test key, not real)
      `-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC7o4qne60TB3pO
YaBy3RBBKQ+VQMPBfBMC3JkSWBPgnFhg7kGRaFGbh8UEJxwPbTQFPLaTx3Chf9fB
Pj5mfFMOfVfFSJcoV7JlgrFnpa+IHpHrSCJDhkO3M9cJptHmTsnn8pVzVSyRmiQP
U1GM9aOJOfIxPavz6ACFMBYSkVWAyBIyoOWGxEPP0RGnHBIAIkH4JR98mXp4YP7s
P+QIiUFmcSQGj3LkgSJPxsbJJGLiOR4LFm3YDm1bNRJYEMCxBqJhT9SmaxJPSJjf
fGWJPC7S1E0KIjkAPKRjJHJYHGOjsFBe7RYlxHQsq1q1f0ynpHnMYCa4Svnmlk/h
l4YA8F/bAgMBAAECggEAI1Pg9yGWPiFdw1RA5kh/BIjceTCXgqM/SBTW42MmfYVD
a7RHGBnEj23GHMp3OE4C7HsBj6xaOHITnoa/GcE7anDm5ValmwnC7ykjFGEX7SBm
pBUGaS0TF8L9sjckDNvBNulTPEzGR5EBbHRszFPTnOBb4J8Y7gjQWgml2cOh2bFN
PUQblganDqEz0mPZEaxp8LvvajdVDPrJPe4M0WIJpHql9caVLACKxMn8AGjQ+mhB
HYITHCVF0ZbVN7ViBQ+cah9fJOAoNimIDFOwqjBICKmz0fpaVUAL9V0MQ9QYOVGT
fMCGFmFBHKMCPtJMC3XGFCMAC7W1HXrD+tBHTiq3QQKBgQDwK0gS0PNfaEjd1aTO
a4P2X6XWm0IflvIQzflmyBBr0gIbr2sICIPwLCJIii5EaEdj+VKcb7sMXUxbSJim
hnL8SK+RD6ZqD1v1cDmHb6Rtw7V3oqr3pNJJK0aCJPVDsv9aBhcvHG65ANfBM04d
eFNnH4nMdRvL+YL/h1BYHsm3mwKBgQDnsJYCB7VmES4xHnWMHFLI6J7EU6a01LhK
l6WJrUfB+3sBnV4S8OCQxJx7oF0TSYwg8cSaDDf8BBS7LjjfSamDN3DNVUiOe3dJ
t0f2AElCrv1Bz7QkT1CJi7bx6SXHkjNELh7txuYf9cAD2YvfW8YJv1uWB6dpT8s7
tlv0UGVMUQKBgHLY9cTwH0t8fy7XCe91TQMX7fJR2M5E7n1Mdc5teeZa7j75mi3c
UM08Y3lHqhPYpj7IRKmNjjx0XnB3S8YMOQY7D/k9hH/Jm0vKQcxwWaO3ZezrDhE
cRJxBJP3H3K9Caa9ft6fZ0VR5Ej3seYPJ4JKXQecYCIVqtKMxUwzavWPAoGBAJAn
jGPl4z+GOXSjFooimD59b7G1ryFbp+HUEYC+dPDsCZoI/xTA1Lf3mmGboaVhkJDf
n7UNq33dGmyu6bh7O3qkTIT4Mn8DEwGVQoWt+gTIDnb5K4HGMB6GRSHnLVe/qAz1
vOFKS2A5xdI4E3FTp9CF2a41iu/VPfk7bDUyZbzRAoGAUhUXJMa6d4NlPUy8EJ3F
VPjzEH6oVQGMqg7U1KfpBXME2w4SXQfcJrN23FuJjnR6EXOZ4ZMHPO6aUlnGEjZ2
AqxAKPbPf3XnCj5fcrKW73+MRVatm4FLIOOvB1kEIMIAIjLRsBjKQr1iX45GlAF0
hFI7QwpkWvD7Hv9jKMSmfDs=
-----END PRIVATE KEY-----`,
      ["https://www.googleapis.com/auth/spreadsheets"],
    );

    const parts = jwt.split(".");
    expect(parts).toHaveLength(3);

    const header = JSON.parse(atob(parts[0].replace(/-/g, "+").replace(/_/g, "/")));
    expect(header.alg).toBe("RS256");
    expect(header.typ).toBe("JWT");

    const claims = JSON.parse(atob(parts[1].replace(/-/g, "+").replace(/_/g, "/")));
    expect(claims.iss).toBe("test@example.iam.gserviceaccount.com");
    expect(claims.scope).toBe("https://www.googleapis.com/auth/spreadsheets");
    expect(claims.aud).toBe("https://oauth2.googleapis.com/token");
  });
});

describe("appendToSheet", () => {
  it("calls Sheets API with correct parameters", async () => {
    const mockFetch = vi.fn().mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ updates: { updatedRows: 1 } }),
    });
    vi.stubGlobal("fetch", mockFetch);

    await appendToSheet("fake-access-token", "sheet-id-123", [
      ["2026-02-16", "John", "john@example.com", "Acme", "555-0000", "Hello"],
    ]);

    expect(mockFetch).toHaveBeenCalledWith(
      "https://sheets.googleapis.com/v4/spreadsheets/sheet-id-123/values/Sheet1!A:F:append?valueInputOption=USER_ENTERED",
      expect.objectContaining({
        method: "POST",
        headers: expect.objectContaining({
          Authorization: "Bearer fake-access-token",
        }),
      }),
    );

    vi.unstubAllGlobals();
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npx vitest run src/lib/__tests__/google-sheets.test.ts`
Expected: FAIL — module not found

**Step 3: Write implementation**

Create `src/lib/google-sheets.ts`:

```typescript
const GOOGLE_TOKEN_URL = "https://oauth2.googleapis.com/token";
const SHEETS_API_BASE = "https://sheets.googleapis.com/v4/spreadsheets";

function base64url(data: ArrayBuffer | string): string {
  const str =
    typeof data === "string"
      ? btoa(data)
      : btoa(String.fromCharCode(...new Uint8Array(data)));
  return str.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}

function pemToArrayBuffer(pem: string): ArrayBuffer {
  const b64 = pem
    .replace(/-----BEGIN PRIVATE KEY-----/, "")
    .replace(/-----END PRIVATE KEY-----/, "")
    .replace(/\s/g, "");
  const binary = atob(b64);
  const buffer = new ArrayBuffer(binary.length);
  const view = new Uint8Array(buffer);
  for (let i = 0; i < binary.length; i++) {
    view[i] = binary.charCodeAt(i);
  }
  return buffer;
}

export async function createJWT(
  clientEmail: string,
  privateKey: string,
  scopes: string[],
): Promise<string> {
  const now = Math.floor(Date.now() / 1000);

  const header = { alg: "RS256", typ: "JWT" };
  const claims = {
    iss: clientEmail,
    scope: scopes.join(" "),
    aud: GOOGLE_TOKEN_URL,
    exp: now + 3600,
    iat: now,
  };

  const encodedHeader = base64url(JSON.stringify(header));
  const encodedClaims = base64url(JSON.stringify(claims));
  const signingInput = `${encodedHeader}.${encodedClaims}`;

  const keyData = pemToArrayBuffer(privateKey);
  const cryptoKey = await crypto.subtle.importKey(
    "pkcs8",
    keyData,
    { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
    false,
    ["sign"],
  );

  const signature = await crypto.subtle.sign(
    "RSASSA-PKCS1-v1_5",
    cryptoKey,
    new TextEncoder().encode(signingInput),
  );

  return `${signingInput}.${base64url(signature)}`;
}

export async function getAccessToken(
  clientEmail: string,
  privateKey: string,
): Promise<string> {
  const jwt = await createJWT(clientEmail, privateKey, [
    "https://www.googleapis.com/auth/spreadsheets",
  ]);

  const response = await fetch(GOOGLE_TOKEN_URL, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams({
      grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
      assertion: jwt,
    }),
  });

  if (!response.ok) {
    const text = await response.text();
    throw new Error(`Google auth failed: ${response.status} ${text}`);
  }

  const data = (await response.json()) as { access_token: string };
  return data.access_token;
}

export async function appendToSheet(
  accessToken: string,
  spreadsheetId: string,
  values: string[][],
): Promise<void> {
  const url = `${SHEETS_API_BASE}/${spreadsheetId}/values/Sheet1!A:F:append?valueInputOption=USER_ENTERED`;

  const response = await fetch(url, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${accessToken}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ values }),
  });

  if (!response.ok) {
    const text = await response.text();
    throw new Error(`Sheets API failed: ${response.status} ${text}`);
  }
}
```

**Step 4: Run test to verify it passes**

Run: `npx vitest run src/lib/__tests__/google-sheets.test.ts`
Expected: All tests PASS

**Step 5: Commit**

```bash
git add src/lib/google-sheets.ts src/lib/__tests__/google-sheets.test.ts
git commit -m "feat: add Google Sheets API module with JWT auth and tests"
```

---

### Task 4: Create Resend Email Module

**Files:**
- Create: `src/lib/send-email.ts`
- Create: `src/lib/__tests__/send-email.test.ts`

**Step 1: Write the failing test**

Create `src/lib/__tests__/send-email.test.ts`:

```typescript
import { describe, it, expect, vi } from "vitest";
import { formatContactEmail, sendContactEmail } from "../send-email";

describe("formatContactEmail", () => {
  it("formats email body with all fields", () => {
    const body = formatContactEmail({
      name: "John Doe",
      email: "john@example.com",
      company: "Acme Corp",
      phone: "+1 555-0000",
      message: "Hello, I'm interested in your services.",
    });

    expect(body).toContain("John Doe");
    expect(body).toContain("john@example.com");
    expect(body).toContain("Acme Corp");
    expect(body).toContain("+1 555-0000");
    expect(body).toContain("Hello, I'm interested in your services.");
  });

  it("handles missing optional fields", () => {
    const body = formatContactEmail({
      name: "Jane",
      email: "jane@example.com",
      company: "",
      phone: "",
      message: "Quick question.",
    });

    expect(body).toContain("Jane");
    expect(body).toContain("jane@example.com");
    expect(body).toContain("Not provided");
    expect(body).toContain("Quick question.");
  });
});

describe("sendContactEmail", () => {
  it("calls Resend API with correct payload", async () => {
    const mockSend = vi.fn().mockResolvedValue({ data: { id: "email-123" }, error: null });
    const mockResend = { emails: { send: mockSend } };

    await sendContactEmail(mockResend as any, {
      from: "noreply@earthboundminerals.com",
      to: "info@earthboundminerals.com",
      name: "John Doe",
      email: "john@example.com",
      company: "Acme",
      phone: "555-0000",
      message: "Hello",
    });

    expect(mockSend).toHaveBeenCalledWith(
      expect.objectContaining({
        from: "noreply@earthboundminerals.com",
        to: "info@earthboundminerals.com",
        subject: "New Contact Form Submission from John Doe",
        replyTo: "john@example.com",
      }),
    );
  });

  it("throws on Resend error", async () => {
    const mockSend = vi.fn().mockResolvedValue({
      data: null,
      error: { message: "API key invalid" },
    });
    const mockResend = { emails: { send: mockSend } };

    await expect(
      sendContactEmail(mockResend as any, {
        from: "noreply@test.com",
        to: "info@test.com",
        name: "Test",
        email: "test@test.com",
        company: "",
        phone: "",
        message: "Test",
      }),
    ).rejects.toThrow("API key invalid");
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npx vitest run src/lib/__tests__/send-email.test.ts`
Expected: FAIL — module not found

**Step 3: Write implementation**

Create `src/lib/send-email.ts`:

```typescript
import { Resend } from "resend";

type ContactFields = {
  name: string;
  email: string;
  company: string;
  phone: string;
  message: string;
};

type SendEmailParams = ContactFields & {
  from: string;
  to: string;
};

export function formatContactEmail(fields: ContactFields): string {
  return [
    `Name: ${fields.name}`,
    `Email: ${fields.email}`,
    `Company: ${fields.company || "Not provided"}`,
    `Phone: ${fields.phone || "Not provided"}`,
    "",
    "Message:",
    fields.message,
  ].join("\n");
}

export async function sendContactEmail(
  resend: Resend,
  params: SendEmailParams,
): Promise<void> {
  const { data, error } = await resend.emails.send({
    from: params.from,
    to: params.to,
    subject: `New Contact Form Submission from ${params.name}`,
    replyTo: params.email,
    text: formatContactEmail(params),
  });

  if (error) {
    throw new Error(error.message);
  }
}
```

**Step 4: Run test to verify it passes**

Run: `npx vitest run src/lib/__tests__/send-email.test.ts`
Expected: All tests PASS

**Step 5: Commit**

```bash
git add src/lib/send-email.ts src/lib/__tests__/send-email.test.ts
git commit -m "feat: add Resend email module with contact formatting and tests"
```

---

### Task 5: Create Server Action

**Files:**
- Create: `src/app/contact/actions.ts`

**Step 1: Write the server action**

Create `src/app/contact/actions.ts`:

```typescript
"use server";

import { headers } from "next/headers";
import { getCloudflareContext } from "@opennextjs/cloudflare";
import { Resend } from "resend";
import { checkRateLimit } from "@/lib/rate-limit";
import { getAccessToken, appendToSheet } from "@/lib/google-sheets";
import { sendContactEmail } from "@/lib/send-email";

type SubmitResult = {
  success: boolean;
  error?: string;
};

const RATE_LIMIT = 5;

export async function submitContact(formData: FormData): Promise<SubmitResult> {
  // Extract fields
  const name = (formData.get("name") as string)?.trim() ?? "";
  const email = (formData.get("email") as string)?.trim() ?? "";
  const company = (formData.get("company") as string)?.trim() ?? "";
  const phone = (formData.get("phone") as string)?.trim() ?? "";
  const message = (formData.get("message") as string)?.trim() ?? "";
  const honeypot = (formData.get("website") as string) ?? "";

  // Honeypot check — bots fill hidden fields
  if (honeypot) {
    return { success: true };
  }

  // Server-side validation
  if (!name) return { success: false, error: "Name is required." };
  if (!email) return { success: false, error: "Email is required." };
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
    return { success: false, error: "Please enter a valid email address." };
  }
  if (!message) return { success: false, error: "Message is required." };

  // Get Cloudflare context
  const { env } = getCloudflareContext();

  // Rate limiting
  const headersList = await headers();
  const ip = headersList.get("cf-connecting-ip") ?? headersList.get("x-forwarded-for") ?? "unknown";
  const { allowed } = await checkRateLimit(env.CONTACT_RATE_LIMIT, ip, RATE_LIMIT);
  if (!allowed) {
    return { success: false, error: "Too many submissions. Please try again later." };
  }

  // Send email + append to Google Sheets in parallel
  const timestamp = new Date().toISOString();
  const results = await Promise.allSettled([
    // Email via Resend
    (async () => {
      const resend = new Resend(env.RESEND_API_KEY);
      await sendContactEmail(resend, {
        from: env.RESEND_FROM_EMAIL,
        to: env.CONTACT_TO_EMAIL,
        name,
        email,
        company,
        phone,
        message,
      });
    })(),
    // Google Sheets
    (async () => {
      const serviceAccount = JSON.parse(env.GOOGLE_SERVICE_ACCOUNT_KEY) as {
        client_email: string;
        private_key: string;
      };
      const accessToken = await getAccessToken(
        serviceAccount.client_email,
        serviceAccount.private_key,
      );
      await appendToSheet(accessToken, env.GOOGLE_SHEET_ID, [
        [timestamp, name, email, company, phone, message],
      ]);
    })(),
  ]);

  // Log failures but don't expose to user
  for (const result of results) {
    if (result.status === "rejected") {
      console.error("Contact submission partial failure:", result.reason);
    }
  }

  // Only fail if both failed
  const allFailed = results.every((r) => r.status === "rejected");
  if (allFailed) {
    return { success: false, error: "Something went wrong. Please try again later." };
  }

  return { success: true };
}
```

**Step 2: Verify types compile**

Run: `npx tsc --noEmit`
Expected: No type errors

**Step 3: Commit**

```bash
git add src/app/contact/actions.ts
git commit -m "feat: add submitContact server action with validation, rate limiting, email, and sheets"
```

---

### Task 6: Update Contact Page

**Files:**
- Modify: `src/app/contact/page.tsx`

**Step 1: Refactor to use server action and add honeypot**

Replace the entire `src/app/contact/page.tsx` with:

```tsx
"use client";

import { useState, useTransition } from "react";
import { Mail, Phone, MapPin } from "lucide-react";
import PageHero from "@/components/PageHero";
import { SITE } from "@/lib/constants";
import { submitContact } from "./actions";

type FormData = {
  name: string;
  email: string;
  company: string;
  phone: string;
  message: string;
};

const initialForm: FormData = {
  name: "",
  email: "",
  company: "",
  phone: "",
  message: "",
};

export default function ContactPage() {
  const [form, setForm] = useState<FormData>(initialForm);
  const [submitted, setSubmitted] = useState(false);
  const [serverError, setServerError] = useState<string | null>(null);
  const [errors, setErrors] = useState<Partial<Record<keyof FormData, string>>>({});
  const [isPending, startTransition] = useTransition();

  function validate(): boolean {
    const next: Partial<Record<keyof FormData, string>> = {};
    if (!form.name.trim()) next.name = "Name is required.";
    if (!form.email.trim()) {
      next.email = "Email is required.";
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(form.email)) {
      next.email = "Please enter a valid email address.";
    }
    if (!form.message.trim()) next.message = "Message is required.";
    setErrors(next);
    return Object.keys(next).length === 0;
  }

  function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    if (!validate()) return;

    setServerError(null);
    const formData = new FormData(e.currentTarget);

    startTransition(async () => {
      const result = await submitContact(formData);
      if (result.success) {
        setSubmitted(true);
      } else {
        setServerError(result.error ?? "Something went wrong.");
      }
    });
  }

  function handleChange(
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>,
  ) {
    setForm((prev) => ({ ...prev, [e.target.name]: e.target.value }));
    if (errors[e.target.name as keyof FormData]) {
      setErrors((prev) => ({ ...prev, [e.target.name]: undefined }));
    }
  }

  const inputClass =
    "w-full rounded-lg border border-brand-sand-dark bg-white px-4 py-3 text-sm text-brand-black placeholder:text-brand-stone focus:border-brand-gold focus:outline-none focus:ring-1 focus:ring-brand-gold transition-colors";

  return (
    <>
      <PageHero
        title="Get in Touch"
        subtitle="Have a question or want to discuss a partnership? We'd love to hear from you."
        breadcrumb="Contact"
      />

      <section className="bg-white py-24">
        <div className="mx-auto max-w-7xl px-6">
          <div className="grid gap-16 lg:grid-cols-2">
            {/* Contact Form */}
            <div>
              {submitted ? (
                <div className="rounded-xl bg-brand-sand p-10 text-center">
                  <div className="mx-auto mb-4 flex h-14 w-14 items-center justify-center rounded-full bg-brand-gold-dark/10">
                    <Mail className="h-6 w-6 text-brand-gold-dark" />
                  </div>
                  <h3 className="text-2xl font-bold text-brand-black">
                    Thank You!
                  </h3>
                  <p className="mt-2 text-brand-stone-dark">
                    Your message has been received. We&apos;ll get back to you
                    as soon as possible.
                  </p>
                </div>
              ) : (
                <>
                  <h2 className="text-2xl font-bold text-brand-black">
                    Send Us a Message
                  </h2>

                  <form
                    onSubmit={handleSubmit}
                    noValidate
                    className="mt-8 space-y-6"
                  >
                    {/* Honeypot — hidden from real users */}
                    <div className="hidden" aria-hidden="true">
                      <label htmlFor="website">Website</label>
                      <input
                        type="text"
                        id="website"
                        name="website"
                        tabIndex={-1}
                        autoComplete="off"
                      />
                    </div>

                    {/* Name */}
                    <div>
                      <label
                        htmlFor="name"
                        className="text-sm font-medium text-brand-stone-dark"
                      >
                        Name <span className="text-brand-gold-dark">*</span>
                      </label>
                      <input
                        id="name"
                        name="name"
                        type="text"
                        required
                        value={form.name}
                        onChange={handleChange}
                        placeholder="Your full name"
                        className={`mt-1.5 ${inputClass}`}
                      />
                      {errors.name && (
                        <p className="mt-1 text-xs text-red-600">
                          {errors.name}
                        </p>
                      )}
                    </div>

                    {/* Email */}
                    <div>
                      <label
                        htmlFor="email"
                        className="text-sm font-medium text-brand-stone-dark"
                      >
                        Email <span className="text-brand-gold-dark">*</span>
                      </label>
                      <input
                        id="email"
                        name="email"
                        type="email"
                        required
                        value={form.email}
                        onChange={handleChange}
                        placeholder="you@example.com"
                        className={`mt-1.5 ${inputClass}`}
                      />
                      {errors.email && (
                        <p className="mt-1 text-xs text-red-600">
                          {errors.email}
                        </p>
                      )}
                    </div>

                    {/* Company */}
                    <div>
                      <label
                        htmlFor="company"
                        className="text-sm font-medium text-brand-stone-dark"
                      >
                        Company
                      </label>
                      <input
                        id="company"
                        name="company"
                        type="text"
                        value={form.company}
                        onChange={handleChange}
                        placeholder="Your company name"
                        className={`mt-1.5 ${inputClass}`}
                      />
                    </div>

                    {/* Phone */}
                    <div>
                      <label
                        htmlFor="phone"
                        className="text-sm font-medium text-brand-stone-dark"
                      >
                        Phone
                      </label>
                      <input
                        id="phone"
                        name="phone"
                        type="tel"
                        value={form.phone}
                        onChange={handleChange}
                        placeholder="+1 (555) 000-0000"
                        className={`mt-1.5 ${inputClass}`}
                      />
                    </div>

                    {/* Message */}
                    <div>
                      <label
                        htmlFor="message"
                        className="text-sm font-medium text-brand-stone-dark"
                      >
                        Message{" "}
                        <span className="text-brand-gold-dark">*</span>
                      </label>
                      <textarea
                        id="message"
                        name="message"
                        required
                        rows={5}
                        value={form.message}
                        onChange={handleChange}
                        placeholder="How can we help you?"
                        className={`mt-1.5 ${inputClass} resize-none`}
                      />
                      {errors.message && (
                        <p className="mt-1 text-xs text-red-600">
                          {errors.message}
                        </p>
                      )}
                    </div>

                    {/* Server error */}
                    {serverError && (
                      <p className="rounded-lg bg-red-50 px-4 py-3 text-sm text-red-600">
                        {serverError}
                      </p>
                    )}

                    <button
                      type="submit"
                      disabled={isPending}
                      className="w-full rounded-lg bg-brand-gold py-3 font-semibold text-brand-black hover:bg-brand-gold-light transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      {isPending ? "Sending..." : "Send Message"}
                    </button>
                  </form>
                </>
              )}
            </div>

            {/* Contact Info — unchanged */}
            <div>
              <div className="rounded-xl bg-brand-sand p-8 lg:p-10">
                <p className="text-xs font-medium uppercase tracking-[0.25em] text-brand-gold-dark">
                  Contact Information
                </p>
                <div className="mt-4 h-px w-16 bg-brand-gold/50" />

                <div className="mt-8 space-y-0">
                  {/* Email */}
                  <div className="flex items-start gap-4">
                    <div className="flex h-10 w-10 shrink-0 items-center justify-center rounded-lg bg-brand-gold-dark/10">
                      <Mail className="h-5 w-5 text-brand-gold-dark" />
                    </div>
                    <div>
                      <p className="text-xs uppercase tracking-wide text-brand-stone">
                        Email
                      </p>
                      <a
                        href={`mailto:${SITE.email}`}
                        className="text-base text-brand-black hover:text-brand-gold-dark transition-colors"
                      >
                        {SITE.email}
                      </a>
                    </div>
                  </div>

                  <div className="my-5 h-px bg-brand-sand-dark" />

                  {/* Phone */}
                  <div className="flex items-start gap-4">
                    <div className="flex h-10 w-10 shrink-0 items-center justify-center rounded-lg bg-brand-gold-dark/10">
                      <Phone className="h-5 w-5 text-brand-gold-dark" />
                    </div>
                    <div>
                      <p className="text-xs uppercase tracking-wide text-brand-stone">
                        Phone
                      </p>
                      <a
                        href={`tel:${SITE.phone}`}
                        className="text-base text-brand-black hover:text-brand-gold-dark transition-colors"
                      >
                        {SITE.phone}
                      </a>
                    </div>
                  </div>

                  <div className="my-5 h-px bg-brand-sand-dark" />

                  {/* Address */}
                  <div className="flex items-start gap-4">
                    <div className="flex h-10 w-10 shrink-0 items-center justify-center rounded-lg bg-brand-gold-dark/10">
                      <MapPin className="h-5 w-5 text-brand-gold-dark" />
                    </div>
                    <div>
                      <p className="text-xs uppercase tracking-wide text-brand-stone">
                        Address
                      </p>
                      <p className="text-base text-brand-black">
                        {SITE.address}
                      </p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
    </>
  );
}
```

Key changes from original:
- Added `useTransition` for pending state
- Added `serverError` state for server-side errors
- Added honeypot hidden field (`website`)
- `handleSubmit` now calls `submitContact` server action via `startTransition`
- Button shows "Sending..." while pending and is disabled
- Server error displayed in a styled box above the button

**Step 2: Verify types compile**

Run: `npx tsc --noEmit`
Expected: No type errors

**Step 3: Commit**

```bash
git add src/app/contact/page.tsx
git commit -m "feat: wire contact form to server action with honeypot and loading state"
```

---

### Task 7: Build Verification & Cleanup

**Step 1: Run all tests**

Run: `npx vitest run`
Expected: All tests pass

**Step 2: Run lint**

Run: `npm run lint`
Expected: No errors

**Step 3: Run build**

Run: `npm run build`
Expected: Build succeeds

**Step 4: Run type check**

Run: `npx tsc --noEmit`
Expected: No errors

**Step 5: Add .dev.vars to .gitignore if not already there**

Check `.gitignore` for `.dev.vars`. If missing, add it:

```
.dev.vars
```

**Step 6: Final commit if any cleanup needed**

```bash
git add -A
git commit -m "chore: build verification and cleanup"
```

---

## Post-Implementation Setup Guide

After the code is deployed, the user needs to complete these manual steps:

### 1. Cloudflare KV Namespace

```bash
npx wrangler kv namespace create CONTACT_RATE_LIMIT
# Copy the ID and update wrangler.jsonc
```

### 2. Resend Setup

1. Sign up at https://resend.com
2. Add and verify domain `earthboundminerals.com`
3. Create API key
4. Set secret: `npx wrangler secret put RESEND_API_KEY`

### 3. Google Sheets Setup

1. Create a Google Cloud project
2. Enable the Google Sheets API
3. Create a service account and download the JSON key
4. Create a Google Sheet with columns: `Timestamp | Name | Email | Company | Phone | Message`
5. Share the sheet with the service account email (Editor access)
6. Set secrets:
   - `npx wrangler secret put GOOGLE_SERVICE_ACCOUNT_KEY` (paste the full JSON)
   - `npx wrangler secret put GOOGLE_SHEET_ID` (the spreadsheet ID from the URL)

### 4. Cloudflare Email Routing

1. Dashboard → Domain → Email → Email Routing
2. Add custom address: `info@earthboundminerals.com`
3. Set forwarding destination
